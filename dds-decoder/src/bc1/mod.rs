#![allow(clippy::needless_range_loop)]

// This code is mostly based on the official microsoft documentation:
// https://learn.microsoft.com/en-us/windows/win32/direct3d9/opaque-and-1-bit-alpha-textures

// NOTE: this may still be very slightly off. When comparing the output of this decoder to the DDS
// file generated by gust_tools in GIMP, it appears that this version is slightly less saturated. In
// IrfanView, the effect seems to be reversed.

use crate::{Color4, ColorBlock};

pub fn read_image(data: &[u8], width: usize, height: usize) -> Vec<u8> {
	let blocks_x = usize::max(1, (width + 3) / 4);
	let blocks_y = usize::max(1, (height + 3) / 4);
	let block_count = blocks_x * blocks_y;
	let decoded_pixel_count = block_count * 16;

	// BC1 has a chunk size of 8 bytes which decodes in a 4x4 block of pixels (64 bytes as RGBA8)
	let mut decoded_pixels = vec![Color4::default(); decoded_pixel_count];
	for (chunk_index, chunk) in data.chunks_exact(8).enumerate() {
		let chunk = decode_block(chunk);

		// copy the chunk into the decoded pixels
		let chunk_x = (chunk_index % blocks_x) * 4;
		let chunk_y = (chunk_index / blocks_x) * 4;
		let target_index = chunk_y * (blocks_x * 4) + chunk_x;

		#[allow(clippy::needless_range_loop)]
		for y in 0..4 {
			for x in 0..4 {
				let target_index = target_index + y * (blocks_x * 4) + x;
				decoded_pixels[target_index] = chunk[y][x];
			}
		}
	}

	let decoded_pixels = decoded_pixels
		.into_iter()
		.flat_map(|color| color.components)
		.collect::<Vec<_>>();

	// the decoded pixels may contain some "padding" on each row, since the width and height may not
	// be divisible by the decoded block size
	let mut final_pixels = vec![0u8; width * height * 4];
	let decoded_pixels_line_bytes = blocks_x * 4 * 4;
	decoded_pixels
		.chunks_exact(decoded_pixels_line_bytes)
		.take(height)
		.enumerate()
		.for_each(|(row, line)| {
			let line_offset = width * row * 4;
			final_pixels[line_offset..(line_offset + width * 4)]
				.copy_from_slice(&line[0..width * 4]);
		});

	tracing::debug!("image decoded");

	final_pixels
}

fn decode_block(block: &[u8]) -> ColorBlock {
	debug_assert_eq!(block.len(), 8);

	let color_0 = u16::from_le_bytes([block[0], block[1]]);
	let color_1 = u16::from_le_bytes([block[2], block[3]]);
	let bitmap = u32::from_le_bytes([block[4], block[5], block[6], block[7]]);

	// if color0 > color1, the color format is RGB 5:6:5
	// otherwise, the color format is RGBA 5:5:5:1
	let is_opaque = color_0 > color_1;

	let color_0 = unpack_color_565(color_0);
	let color_1 = unpack_color_565(color_1);

	let mut color_block = ColorBlock::default();
	for y in 0..4 {
		for x in 0..4 {
			let bits = (bitmap >> ((x + y * 4) * 2)) & 0b11;
			color_block[y][x] = if is_opaque {
				match bits {
					0b00 => color_0,
					0b01 => color_1,
					0b10 => interp_color_2_opaque(color_0, color_1),
					0b11 => interp_color_3_opaque(color_0, color_1),
					_ => unreachable!(),
				}
			} else {
				match bits {
					0b00 => color_0,
					0b01 => color_1,
					0b10 => interp_color_2_transparent(color_0, color_1),
					0b11 => interp_color_3_transparent(color_0, color_1),
					_ => unreachable!(),
				}
			};
		}
	}

	color_block
}

/// Unpacks a u16 color value into an RGBA color. Note that the alpha component is always 255 and it
/// is read as BGR, not RGB.
fn unpack_color_565(color: u16) -> Color4 {
	Color4 {
		components: [
			(((color >> 11) & 0b1_1111) << 3) as u8,
			(((color >> 5) & 0b11_1111) << 2) as u8,
			((color & 0b1_1111) << 3) as u8,
			255,
		],
	}
}

fn interp_color_2_opaque(color_0: Color4, color_1: Color4) -> Color4 {
	Color4 {
		components: [
			((2 * color_0.components[0] as usize + color_1.components[0] as usize + 1) / 3) as u8,
			((2 * color_0.components[1] as usize + color_1.components[1] as usize + 1) / 3) as u8,
			((2 * color_0.components[2] as usize + color_1.components[2] as usize + 1) / 3) as u8,
			((2 * color_0.components[3] as usize + color_1.components[3] as usize + 1) / 3) as u8,
		],
	}
}

fn interp_color_3_opaque(color_0: Color4, color_1: Color4) -> Color4 {
	Color4 {
		components: [
			((color_0.components[0] as usize + 2 * color_1.components[0] as usize + 1) / 3) as u8,
			((color_0.components[1] as usize + 2 * color_1.components[1] as usize + 1) / 3) as u8,
			((color_0.components[2] as usize + 2 * color_1.components[2] as usize + 1) / 3) as u8,
			((color_0.components[3] as usize + 2 * color_1.components[3] as usize + 1) / 3) as u8,
		],
	}
}

fn interp_color_2_transparent(color_0: Color4, color_1: Color4) -> Color4 {
	Color4 {
		components: [
			((color_0.components[0] as usize + color_1.components[0] as usize) / 2) as u8,
			((color_0.components[1] as usize + color_1.components[1] as usize) / 2) as u8,
			((color_0.components[2] as usize + color_1.components[2] as usize) / 2) as u8,
			((color_0.components[3] as usize + color_1.components[3] as usize) / 2) as u8,
		],
	}
}

fn interp_color_3_transparent(_: Color4, _: Color4) -> Color4 {
	Color4::TRANSPARENT
}
